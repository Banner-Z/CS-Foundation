# 排序

## 目录

[TOC]

## 简述

1. **稳定性**是指有两个及以上的相同关键字时排序前后这些关键字的相对位置，没有变化即为稳定。

2. 分类：插入类、交换类、选择类、归并类、基数类

### 插入类

#### 直接插入排序

​	往一个有序序列中直接插入。时间n^2，空间1。

#### 折半插入排序

​	往一个有序序列中二分插入。时间最好nlog2n，最差n^2，平均n^2。空间1。

#### 希尔排序

​	也叫缩小增量排序。按照增量分割出多组的关键字序列（如增量5，则隔4个取一个组成5个序列，分别排序），然后合并，再以更小的增量分割排序，最后一次增量为1。易知，**希尔排序是不稳定的**。

​	希尔排序的时间复杂度和增量的选取有关，常见的选取规则有：

​		希尔自己的——|_ n/2 _ |, |_ n/4 _|，...，| _n/2^k _|, ... ，1。（| _ 表示下取整。。。）

​		Papernov & Stasevich 的—— (2^k)+1, ..., 3, 1。

​	增量序列中应尽量没有除1之外的公因子。

​	空间1。

### 交换类排序

#### 起泡排序

​	**结束条件为在一趟排序中没有发生关键字的交换**。最好n，最坏n^2，平均n^2，空间1。

#### 快速排序

​	每趟选择所有子序列中的一个关键字（通常为第一个）作为枢轴，把比枢轴大、小的放在右、左边，划分完后得到一组更短的子序列。

​	具体扫描方法：用一对 i j 从子序列的两头开始，j 先动，找到第一个小于的，放到 i 指向的枢轴的位置，然后 i 向后走，找到第一个大于的，放到 j 的地方，然后 j 往前 ... ，知道 i j 相遇，放下枢轴在那里。接着把枢轴左、右分出两个子序列，不包括枢轴自己。其实 “ 不包括自己 ” 很重要，（当然没有这样low也不会等于high，也就是不会结束）如果序列已经有序，i j 就会在某一端，所以递归时 i -1，j +1会少减一共 2^k-1 个位置，这也就导致了有序时候效率最低。

​	时间最好nlog2n，最差n^2，平均nlog2n。

​	虽然有多个算法都是nlog2n，但是扩展为 X*nlog2n 来看，快排的 X 是最小的，所以叫快排。

​	空间 log2n，因为有递归。

### 选择类排序

#### 简单选择排序

​	n^2 和 1。过。

#### 堆排序

​	分大顶堆小顶堆。大顶堆为例。首先，他是一棵完全二叉树。。。

​	建堆：从**非叶子节点**中的最底层的最右的一个开始比。

​	插入：放在最底层的最右边，依次上调。

​	删除：把最底层最右边的节点填到删除的节点位置上，依次下调。

​	排序：对一个建好的堆，取第一个和最后一个换，第一个就到达最终位置了，然后把出他以外的剩余部分进行调整，也就是下调现在的第一个，反复进行。

​	时间 nlog2n，最好最坏都是，这是相对于快排的优点。空间 1 ，这是相对于其他nlogn的排序的优点。

​	适合关键字很多的情况，如从10000个中取前10，不适合关键字少的时候。

#### 二路归并排序

​	把原始序列看成n个序列，两两归并，然后再两两归并，直到结束。时间和初始序列的情况无关，最好最坏都是nlog2n。空间n。

#### 基数排序

​	**最高位优先**：按关键字最高位排成几个序列，再对子序列按次高位。。。

​	**最低位优先**：不用分子序列，每次都一起来。把关键字按最低位放进对应的桶里，然后先进的先出一个个取出来，这样最低位有序了，再放次低位的桶。。。

​	时间最好最坏都是 d(n+rd) （d是下标）。d是关键字位数，rd是关键字基的个数，也就是桶数。空间 rd 。

​	适合关键字多但是基取值范围小的时候，基多的话可以用最高位优先。

### 外部排序

​	外部的意思是记录不在内存，在外存。也就是将内存作为工作空间来辅助外存数据的排序。常用归并。

#### k路归并算法

​	简单来说，就是把多个有序记录段的第一个取出来放在内存中排，排出最小的写回外存，拿那组的次小值补上，重复。以此来用较小空间完成较大规模的排序。这称为k路归并算法，k=2时也就是二路归并了。

​	他有很多的子算法来改进，在下面。

#### 置换-选择排序

​	一种适用于初始归并段（被分成多个小记录段的大记录段）、高效的且不受内存空间限制的排序算法。

​	往缓冲区里放记录放满，选出最小的一个写回内存，然后再从外存读进来一个，如果这个比已生成的序列中的最大值要小，那么这个要作为下一个记录段的第一个，不能拿出去，选出剩下当中可以拿出去的里面最小的，继续进行，直到所有的都比已生成序列的最大值小，那么这个序列生成完毕，开始下一个。重复。

​	所以，生成的子序列的长度是不同的。

#### 最佳归并树

​	不同的初始归并段长度不同，所以不同的归并策略需要的I/O次数不同，因此要有一个合适的策略。

​	把归并段长度当作树的节点，用k叉赫夫曼树的方法构建最佳归并树，k也就是要的归并段路数。

#### 败者树

​	原本需要对读入的k个值进行k-1次比较才能得出最值，败者树则需要约 log2k 次。

​	叶子节点：从归并段中读入的段首记录，k路归并段个数为k。

​	非叶子节点：度为2，值为叶子节点的序号，也指示了当前参与选择的记录所在的归并段。

​	构造方法：简单来说，两两相遇时，较大者，也就是败者，的位置（所在归并段的序号）作为两个节点的爹，然后把胜者的位置作为这个爹的爹。复杂来讲，要分叶子和叶子、非叶子和非叶子、叶子和非叶子的相遇情况，懒得说了。

​	调整败者树：整棵树的跟是最小的，放回内存，把那个根对应的序列的下一个放在他原来的叶子节点上。然后从他那里开始比较上去，把他和另一个叶子相遇比出来的爹的爹和原来那个爹的爹比较，重复地相遇上去，也就能再选出一个最小值。

#### 外部排序的时间空间复杂度

​	时间复杂度涉及多个方面，m个初始段进行k路归并的趟数为logkm（k为底数）；败者树的高度为|-log2k-|+1（|-代表上取整。。。），选出最值要|-log2k-|次，也就是时间复杂度；败者树建树时间为klog2k。空间1。

## 部分实现

TBA

## TBA